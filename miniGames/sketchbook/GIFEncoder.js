/**
 * This class handles GIF encoding
 * @constructor
 */
function GIFEncoder() {
    for (var i = 0, chr = {}; i < 256; i++)
        chr[i] = String.fromCharCode(i);

    function ByteArray() {
        this.bin = [];
    }

    ByteArray.prototype.getData = function() {
        for (var v = '', l = this.bin.length, i = 0; i < l; i++)
            v += chr[this.bin[i]];
        return v;
    };

    ByteArray.prototype.writeByte = function(val) {
        this.bin.push(val);
    };

    ByteArray.prototype.writeUTFBytes = function(string) {
        for (var l = string.length, i = 0; i < l; i++)
            this.writeByte(string.charCodeAt(i));
    };

    ByteArray.prototype.writeBytes = function(array, offset, length) {
        for (var l = length || array.length, i = offset || 0; i < l; i++)
            this.writeByte(array[i]);
    };

    var exports = {};

    var width; // image size
    var height;
    var transparent = null; // transparent color if given
    var transIndex; // transparent index in color table
    var repeat = -1; // no repeat
    var delay = 0; // frame delay (hundredths)
    var started = false; // ready to output frames
    var out = new ByteArray();
    var image; // current frame
    var pixels; // BGR byte array from frame
    var indexedPixels; // converted frame indexed to palette
    var colorDepth; // number of bit planes
    var colorTab; // RGB palette
    var usedEntry = new Array(); // active palette entries
    var palSize = 7; // color table size (bits-1)
    var dispose = -1; // disposal code (-1 = use default)
    var closeStream = false; // close stream when finished
    var firstFrame = true;
    var sizeSet = false; // if false, get size from first frame
    var sample = 10; // default sample interval for quantizer
    var comment = "Generated by GIFEncoder JS";

    /**
     * Sets the delay time between each frame, or changes it for subsequent frames
     * (applies to last frame added)
     * @param milliseconds int delay time in milliseconds
     */
    var setDelay = exports.setDelay = function setDelay(milliseconds) {
        delay = Math.round(milliseconds / 10);
    };

    /**
     * Sets frame rate in frames per second.
     * @param fps
     */
    var setFrameRate = exports.setFrameRate = function setFrameRate(fps) {
        if (fps != 0xf) delay = Math.round(100 / fps);
    };

    /**
     * Sets the GIF frame disposal code for the last added frame and any
     * subsequent frames.
     *
     * Default is 0 if no transparent color has been set, otherwise 2.
     * @param code
     */
    var setDispose = exports.setDispose = function setDispose(code) {
        if (code >= 0) dispose = code;
    };

    /**
     * Sets the number of times the set of GIF frames should be played.
     *
     * -1 = play once
     * 0 = repeat indefinitely
     *
     * @param iter int number of iterations.
     * @return
     */
    var setRepeat = exports.setRepeat = function setRepeat(iter) {
        if (iter >= 0) repeat = iter;
    };

    /**
     * Sets the transparent color for the last added frame and any subsequent
     * frames. Since all colors are subject to modification in the quantization
     * process, the color in the final palette for each frame closest to the given
     * color becomes the transparent color for that frame. May be set to null to
     * indicate no transparent color.
     * @param
     * @return
     */
    var setTransparent = exports.setTransparent = function setTransparent(c) {
        transparent = c;
    };

    /**
     * Sets quality of color quantization (conversion of images to the maximum 256
     * colors allowed by the GIF specification).
     *
     * Lower values (minimum = 1) produce better colors, but slow processing
     * significantly. 10 is the default, and produces good color mapping at
     * reasonable speeds. Values greater than 20 do not yield significant
     * improvements in speed.
     *
     * @param quality
     * @return
     */
    var setQuality = exports.setQuality = function setQuality(quality) {
        if (quality < 1) quality = 1;
        sample = quality;
    };

    /**
     * Sets the comment for the block comment
     * @param comment
     */
    var setComment = exports.setComment = function setComment(newComment) {
        comment = newComment;
    };

    /**
     * The addFrame method takes an incoming BitmapData object to create each frames
     * @param im BitmapData object to be treated as a GIF's frame
     */
    var addFrame = exports.addFrame = function addFrame(im, is_imageData) {
        if ((im === null) || !started || out === null) {
            throw new Error("Please call start method before calling addFrame");
        }

        var ok = true;

        try {
            if (!is_imageData) {
                image = im.getImageData(0, 0, im.canvas.width, im.canvas.height).data;
                if (!sizeSet) setSize(im.canvas.width, im.canvas.height);
            } else {
                image = im;
            }
            getImagePixels(); // convert to correct format if necessary
            analyzePixels(); // build color table & map pixels

            if (firstFrame) {
                writeLSD(); // logical screen descriptior
                writePalette(); // global color table
                if (repeat >= 0) {
                    // use NS app extension to indicate reps
                    writeNetscapeExt();
                }
            }

            writeGraphicCtrlExt(); // write graphic control extension
            writeImageDesc(); // image descriptor
            if (!firstFrame) writePalette(); // local color table
            writePixels(); // encode and write pixel data
            firstFrame = false;
        } catch (e) {
            ok = false;
        }

        return ok;
    };

    /**
     * Adds final trailer to the GIF stream, if you don't call the finish method
     * the GIF stream will not be valid.
     */
    var finish = exports.finish = function finish() {
        if (!started) return false;
        var ok = true;
        started = false;
        try {
            out.writeByte(0x3b); // gif trailer
        } catch (e) {
            ok = false;
        }

        return ok;
    };

    /**
     * Resets some members so that a new stream can be started.
     * This method is actually called by the start method
     */
    var reset = function reset() {
        // reset for subsequent use
        transIndex = 0;
        image = null;
        pixels = null;
        indexedPixels = null;
        colorTab = null;
        closeStream = false;
        firstFrame = true;
    };

    /**
     * * Sets frame size
     */
    var setSize = exports.setSize = function setSize(w, h) {
        if (started && !firstFrame) return;
        width = w;
        height = h;
        if (width < 1 || height < 1) throw new Error('Width and height must be positive numbers.');
        sizeSet = true;
    };

    /**
     * Initiates GIF file creation on the given stream.
     */
    var start = exports.start = function start() {
        reset();
        var ok = true;
        closeStream = false;
        out = new ByteArray();
        try {
            out.writeUTFBytes("GIF89a"); // header
        } catch (e) {
            ok = false;
        }
        return started = ok;
    };

    var cont = exports.cont = function cont() {
        reset();
        var ok = true;
        closeStream = false;
        out = new ByteArray();
        return started = ok;
    };

    /**
     * @return Returns the current output stream.
     */
    var stream = exports.stream = function stream() {
        return out;
    };

    var setProperties = exports.setProperties = function setProperties(has_start, is_first) {
        started = has_start;
        firstFrame = is_first;
        closeStream = false;
    };

    return exports;
}

try {
    exports.GIFEncoder = GIFEncoder;
} catch (e) {
    // nothing
} 